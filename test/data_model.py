# coding: utf-8

from fidget import _x as leÎ¨, this, _x, call, _y, x_, _xx

from IPython import display

import pandas

# `a minimalist syntax`

(range - _x - [len] * 10 - [type, _x.first()[type]] - call)(10)

about = _x[dict][_xx["""{Description}
    
{Operator}""".format]][display.Markdown][display.display]

# df = (leÎ¨
# ### extracts <table> tags from the page

#  * pandas.read_html

# ### Report the number of frames found

#  * (leÎ¨<<len&"Loaded {} dataframes".format&print)

# ### The operator precedence is the first one.

#  * leÎ¨.first()

# ### Reverse the dataframe

#  * this.iloc[::-1]

# ) & (
#     ## Call the composition using the docs
#     call('https://docs.python.org/3/reference/expressions.html')
# )
# df
df = pandas.read_csv('dm.csv', index_col="Unnamed: 0")
df

df.iloc[0].pipe(about)

df.iloc[1].pipe(about)

[
    leÎ¨[dir]

    ## Filter non-private methods
    // -_x.get(slice(0, 2)).eq('__')

    ## Vector to Matrix
    >> _x.partition_all(12).map(list)[list][pandas.DataFrame]

    ## Micro repo
    << _x[_x['attributes for {}'.format][print](xxx)]

    ## Customize pandas table
    << _x[this.to_html(index=None)][display.HTML][display.display]

    ## Return nothing after calling, display will have done that.
    >> None >> call(xxx) for xxx in (_y, _x)
]

df.iloc[2].apply('~~{}~~'.format).pipe(about)

df.iloc[3].pipe(about)

# > Only execute a statement when the exponent is true.

# _x[range][list] >> call('asdf')
_x[range][list]**x_(int)[isinstance] >> call('asdf')
(_x[range][list]**x_(int)[isinstance] | str.upper) >> call('asdf')

df.iloc[4].pipe(about)

(+_x[range])(0)
(+_x[range])(1)
(-_x[range])(0)
(-_x[range])(1)

# reverse direction of the functions.

~_x[range][list]

df.iloc[5].pipe(about)

# Use `*` to append function because it is markdowny

(_x * range * list)(10)

# groupby

_x * range @_x.mod(2) & call(10)

# map

_x * range / _x.mod(2) >> list & call(10)

# filter

_x * range // _x.mod(2) >> list & call(10)

# reduce

_x * range % _x.add() & call(10)

_x * range / str % _x.add() & call(10)

df.iloc[6].pipe(about)

# append functions in a markdowny way

_x + range - list + len

df.iloc[7].pipe(about)

_x >> range >> list >> [len, sum] >> call(10)

_x << range >> list >> [len, sum] >> call(10)

_x >> range >> list >> [len, sum] << print >> call(10)

df.iloc[8].pipe(about)

_x & range & list & [len, sum] & call(10)

df.iloc[9].pipe(about)

(_x + str.upper ^ x_(str)[isinstance]) + call(10)

(_x + str.upper ^ x_(str)[isinstance]) + call('asdf10')

df.iloc[10].pipe(about)

conditional = (_x + str.upper ^ x_(str)[isinstance] | _x.mul(10) ^ x_(
    (int, float))[isinstance] | "Can't do anything with {}".format)

conditional({10})

conditional('asdf10')

conditional(10)

df.iloc[11].pipe(about)

_x >> range < _x >> range >> list
_x >> range >> list is not _x >> range >> list
_x >> range >> list == _x >> range >> list

range in _x[range][len]
range not in _x[_x[range]][len]

sumpin = _x
with sumpin**"like an ðŸ’¡" as such:
    such[type]
    such += type
    such *= type
    such -= type
    such * type
    such + type
    such - type
    such[{type, type, type}]
    type + such
    [type] * 10 * such[type]
    such.first()
such

# > logging

from copy import copy

from time import time
log = 'get_ipython' not in globals() and print or get_ipython().log.warning

with [] - _xx[time] as _time_:
    t = _time_()

(_x >> range
 # print intermediate results
 << (_x - [len, sum, _time_ - _x.sub(t) - """{} sec""".format] >> log)
 >> list) >> call(10)
